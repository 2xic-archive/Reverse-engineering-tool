

So I have read that the memory style should be id and then key for the auxiliary vector and that the size should be 4 bytes.
However this does not seem to be correct(or there are something I am missing) based on the stack dump. I found this http://refspecs.linuxbase.org/LSB_1.3.0/IA64/spec/auxiliaryvector.html and there it is 8 byte for the type, 8 byte for the value, 8 byte for the pointer and 8 byte for the function pointer value. Looking at the stack dump from gdb this seems more correct....

0x7fffffffece0:	6	0	4096	0


So here we have a_type = 6 (AT_PAGESZ), however it says that the integer value is zero...  And that the pointer is 4096, that does not seem correct. However the funciton pointer value is zero and that seems reasonable. 

NEVER MIND!
https://android.googlesource.com/platform/prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.7-4.6/+/refs/heads/jb-dev/sysroot/usr/include/elf.h#1599

The problem is because of the diffrence in pointer size between 32 and 64 bit computers.... (uint32_t vs uint64_t). So key, value is correct ;)
0x7fffffffece0:	[6	0](key)	[4096	0](value)

But what about the bytes below? Based on my understaing they should be random bytes(seeding the PRNG).... 

Also I expected that the platform string should be seen on the stack with the program name. I don't see that .... (they should be at the TOP)

							
0x7fffffffec10:	0x00000001[argc]	0x00000000	0xffffee1d	0x00007fff

0x7fffffffec20:	0x00000000	0x00000000	

0xffffee43	0x00007fff
0x7fffffffec30:	0xffffee77	0x00007fff	0xffffee86	0x00007fff
0x7fffffffec40:	0xffffee98	0x00007fff	0xffffeeac	0x00007fff
0x7fffffffec50:	0xffffeeb6	0x00007fff	0xffffeed3	0x00007fff
0x7fffffffec60:	0xffffeedc	0x00007fff	0xffffeee7	0x00007fff
0x7fffffffec70:	0xffffef09	0x00007fff	0xffffef1c	0x00007fff
0x7fffffffec80:	0xffffef27	0x00007fff	0xffffef3b	0x00007fff
0x7fffffffec90:	0xffffef4b	0x00007fff	0xffffef5f	0x00007fff
0x7fffffffeca0:	0xffffef67	0x00007fff	0xffffef74	0x00007fff
0x7fffffffecb0:	0xffffef90	0x00007fff	(0x00000000	0x00000000) 	[padding to align the stack?]

[above should there be some random bytes + names?]
								
0x7fffffffecc0:	0x00000021[AT_SYSINFO_EHDR]	0x00000000	0xf7ffd000	0x00007fff			<-	at here at 0x434e80 first hit(gdb)
0x7fffffffecd0:	0x00000010[AT_HWCAP]		0x00000000	0x078bfbff	0x00000000			<-	at here at 0x434e80 first hit (unicorn)
																							I did some futher research.. I think the problem was because of envp. 
0x7fffffffece0:	0x00000006[AT_PAGESZ]		0x00000000	0x00001000	0x00000000
0x7fffffffecf0:	0x00000011[AT_CLKTCK]		0x00000000	0x00000064	0x00000000
0x7fffffffed00:	0x00000003[AT_PHDR]			0x00000000	0x00400040	0x00000000
0x7fffffffed10:	0x00000004[AT_PHENT]		0x00000000	0x00000038	0x00000000
0x7fffffffed20:	0x00000005[AT_PHNUM]		0x00000000	0x00000006	0x00000000
0x7fffffffed30:	0x00000007[AT_BASE]			0x00000000	0x00000000	0x00000000
0x7fffffffed40:	0x00000008[AT_FLAGS]		0x00000000	0x00000000	0x00000000
0x7fffffffed50:	0x00000009[AT_ENTRY]		0x00000000	0x00400990	0x00000000
0x7fffffffed60:	0x0000000b[AT_UID]			0x00000000	0x00000000	0x00000000
0x7fffffffed70:	0x0000000c[AT_EUID]			0x00000000	0x00000000	0x00000000
0x7fffffffed80:	0x0000000d[AT_GID]			0x00000000	0x00000000	0x00000000
0x7fffffffed90:	0x0000000e[AT_EGID]			0x00000000	0x00000000	0x00000000



[UNICORN]
	0x19ffe28		01000000	00000000	(00000000	00000000)[NULL ARGV]
	0x19ffe38		(00000000	00000000)(zero envp)	(00000000	00000000)[NULL ENVP]

	0x19ffe48		21000000[AT_SYSINFO_EHDR]	00000000	00000000	00000000
	0x19ffe58		10000000[AT_HWCAP]	00000000	00100000	00000000
	0x19ffe68		06000000[AT_PAGESZ]	00000000	64000000	00000000
	0x19ffe78		11000000[AT_CLKTCK]	00000000	40004000	00000000

	0x19ffe88		03000000[AT_PHDR]	00000000	38000000	00000000
	0x19ffe98		04000000[AT_PHENT]	00000000	06000000	00000000
	0x19ffea8		05000000[AT_PHNUM]	00000000	00000040	00000000
	0x19ffeb8		07000000[AT_BASE]	00000000	00000000	00000000
	0x19ffec8		08000000[AT_FLAGS]	00000000	90094000	00000000
	0x19ffed8		09000000[AT_ENTRY]	00000000	00000000	00000000
	0x19ffee8		0b000000[AT_UID]	00000000	00000000	00000000
	0x19ffef8		0c000000[AT_EUID]	00000000	00000000	00000000
	0x19fff08		0d000000[AT_GID]	00000000	00000000	00000000
	0x19fff18		0e000000[AT_EGID]	00000000	00000000	00000000
	0x19fff28		17000000[AT_SECURE]	00000000	00000000	00000000


[GDB]
	0x7fffffffec10:	1	0	-4589	32767
	0x7fffffffec20:	0	0	-4546	32767
	0x7fffffffec30:	-4494	32767	-4479	32767
	0x7fffffffec40:	-4461	32767	-4441	32767
	0x7fffffffec50:	-4431	32767	-4402	32767
	0x7fffffffec60:	-4393	32767	-4382	32767
	0x7fffffffec70:	-4348	32767	-4329	32767
	0x7fffffffec80:	-4318	32767	-4298	32767
	0x7fffffffec90:	-4282	32767	-4262	32767
	0x7fffffffeca0:	-4254	32767	-4241	32767
	0x7fffffffecb0:	-4213	32767	0	0
	0x7fffffffecc0:	33	0	-134230016	32767
	0x7fffffffecd0:	16	0	126614527	0
	0x7fffffffece0:	6	0	4096	0
	0x7fffffffecf0:	17	0	100	0
	0x7fffffffed00:	3	0	4194368	0
	0x7fffffffed10:	4	0	56	0
	0x7fffffffed20:	5	0	6	0
	0x7fffffffed30:	7	0	0	0
	0x7fffffffed40:	8	0	0	0
	0x7fffffffed50:	9	0	4196752	0
	0x7fffffffed60:	11	0	0	0
	0x7fffffffed70:	12	0	0	0
	0x7fffffffed80:	13	0	0	0
	0x7fffffffed90:	14	0	0	0

Renaming binary ONLY
	0x7fffffffec10:	0x00000001	0x00000000	0xffffee13	0x00007fff
	0x7fffffffec20:	0x00000000	0x00000000	0xffffee3e	0x00007fff
	0x7fffffffec30:	0xffffee72	0x00007fff	0xffffee81	0x00007fff
	0x7fffffffec40:	0xffffee93	0x00007fff	0xffffeea7	0x00007fff
	0x7fffffffec50:	0xffffeeb1	0x00007fff	0xffffeece	0x00007fff
	0x7fffffffec60:	0xffffeed7	0x00007fff	0xffffeee2	0x00007fff
	0x7fffffffec70:	0xffffef04	0x00007fff	0xffffef17	0x00007fff
	0x7fffffffec80:	0xffffef22	0x00007fff	0xffffef36	0x00007fff
	0x7fffffffec90:	0xffffef46	0x00007fff	0xffffef5a	0x00007fff
	0x7fffffffeca0:	0xffffef62	0x00007fff	0xffffef6f	0x00007fff
	0x7fffffffecb0:	0xffffef8b	0x00007fff	0x00000000	0x00000000



0000000000434eb0         add        rdi, 0x10 				at rdi ->	gdb reports 0x00000021, jumps to  0x00000010,
																		from AT_SYSINFO_EHDR->AT_HWCAP
															unicorn rdi ->	unicorn reports 0x00000021, but adding 16 bytes moves it to 
																			AT_HWCAP. Okay so all good.
																		->	after a while it goes wrong... (see the jump)
0000000000434eb4         mov        rax, qword [rdi]
0000000000434eb7         test       rax, rax				
0000000000434eba         jne        loc_434e80



I wounder why I didn't see the strings. oh maybe because I forgot to dump the entire stack :=) (grr!)
Dumping the entire stack
	0x7fffffffec30:	0x00000001	0x00000000	[0xffffee34	0x00007fff](program name)
	0x7fffffffec40:	0x00000000	0x00000000[NULL]	0xffffee4f	0x00007fff
	0x7fffffffec50:	0xffffee83	0x00007fff	0xffffee92	0x00007fff
	0x7fffffffec60:	0xffffeea4	0x00007fff	0xffffeeb6	0x00007fff 			<-	all of that is envp !
	0x7fffffffec70:	0xffffeec0	0x00007fff	0xffffeedd	0x00007fff
	0x7fffffffec80:	0xffffeee6	0x00007fff	0xffffeef1	0x00007fff
	0x7fffffffec90:	0xffffef13	0x00007fff	0xffffef26	0x00007fff
	0x7fffffffeca0:	0xffffef32	0x00007fff	0xffffef46	0x00007fff
	0x7fffffffecb0:	0xffffef56	0x00007fff	0xffffef6a	0x00007fff
	0x7fffffffecc0:	0xffffef72	0x00007fff	0xffffef7f	0x00007fff
	0x7fffffffecd0:	0xffffef9b	0x00007fff	0x00000000	0x00000000[NULL]		   <- envp end!

	0x7fffffffece0:	0x00000021[AT_SYSINFO_EHDR]	0x00000000	0xf7ffd000	0x00007fff
	0x7fffffffecf0:	0x00000010[AT_HWCAP]	0x00000000	0x078bfbff	0x00000000
	0x7fffffffed00:	0x00000006[AT_PAGESZ]	0x00000000	0x00001000	0x00000000
	0x7fffffffed10:	0x00000011[AT_CLKTCK]	0x00000000	0x00000064	0x00000000
	0x7fffffffed20:	0x00000003[AT_PHDR]	0x00000000	0x00400040	0x00000000
	0x7fffffffed30:	0x00000004[AT_PHENT]	0x00000000	0x00000038	0x00000000
	0x7fffffffed40:	0x00000005[AT_PHNUM]	0x00000000	0x00000006	0x00000000
	0x7fffffffed50:	0x00000007[AT_BASE]	0x00000000	0x00000000	0x00000000
	0x7fffffffed60:	0x00000008[AT_FLAGS]	0x00000000	0x00000000	0x00000000
	0x7fffffffed70:	0x00000009[AT_ENTRY]	0x00000000	0x00400990	0x00000000
	0x7fffffffed80:	0x0000000b[AT_UID]	0x00000000	0x00000000	0x00000000
	0x7fffffffed90:	0x0000000c[AT_EUID]	0x00000000	0x00000000	0x00000000
	0x7fffffffeda0:	0x0000000d[AT_GID]	0x00000000	0x00000000	0x00000000
	0x7fffffffedb0:	0x0000000e[AT_EGID]	0x00000000	0x00000000	0x00000000


	0x7fffffffedc0:	0x00000017[AT_SECURE]	0x00000000	0x00000000	0x00000000
	0x7fffffffedd0:	0x00000019[AT_RANDOM]	0x00000000	0xffffee19	0x00007fff
	0x7fffffffede0:	0x0000001f[AT_EXECFN]	0x00000000	0xffffefdd	0x00007fff
	0x7fffffffedf0:	0x0000000f[AT_PLATFORM]	0x00000000	0xffffee29	0x00007fff
	0x7fffffffee00:	0x00000000[AT_NULL]		0x00000000	0x00000000	0x00000000
	0x7fffffffee10:	0x00000000	0x00000000	(stack aligment ? )
	
[	0xc2fbc100	0x68c0f579
	0x7fffffffee20:	0xd53ac5b0	0x17c1f949	](I think this is the random data )


	0x36387880	0x0034365f 					(this sohuld be where the program data is stored
											yes ! past me, you are correct. Check it with the nice stack string functioN!

											x86_64
	)

	0x7fffffffee30:	0x00000000	0x6f6f722f	0x65742f74	0x742f7473  /root/test/test_binaries/s
	0x7fffffffee40:	0x5f747365	0x616e6962	0x73656972	0x5300732f  S
	
	*	removed 3 entries, you know your ip is on the stack?	*

	0x7fffffffee80:	0x5f003232	0x73752f3d	0x69622f72	0x64672f6e 	22
	0x7fffffffee90:	0x4c4f0062	0x44575044	0x6f722f3d	0x742f746f 	_=/usr/bin/gdb
	0x7fffffffeea0:	0x00747365	0x5f474458	0x53534553	0x5f4e4f49  est
	0x7fffffffeeb0:	0x313d4449	0x53550037	0x723d5245	0x00746f6f  XDG_SESSION_ID=17
																	USER=root

	0x7fffffffeec0:	0x3d445750	0x6f6f722f	0x65742f74	0x742f7473
	0x7fffffffeed0:	0x5f747365	0x616e6962	0x73656972	0x4e494c00
	0x7fffffffeee0:	0x333d5345	0x4f480032	0x2f3d454d	0x746f6f72
																	PWD=/root/test/test_binaries
																	LINES=32
																	HOME=/root

	*	removed 2 entries, you know your ip is on the stack?	*
	
	0x7fffffffef10:	0x53003232	0x545f4853	0x2f3d5954	0x2f766564
	0x7fffffffef20:	0x2f737470	0x4f430033	0x4e4d554c	0x31313d53
	0x7fffffffef30:	0x414d0034	0x2f3d4c49	0x2f726176	0x6c69616d
	0x7fffffffef40:	0x6f6f722f	0x48530074	0x3d4c4c45	0x6e69622f
	0x7fffffffef50:	0x7361622f	0x45540068	0x783d4d52	0x6d726574
	0x7fffffffef60:	0x3635322d	0x6f6c6f63	0x48530072	0x3d4c564c
	0x7fffffffef70:	0x4f4c0031	0x4d414e47	0x6f723d45	0x5800746f
	0x7fffffffef80:	0x525f4744	0x49544e55	0x445f454d	0x2f3d5249
	0x7fffffffef90:	0x2f6e7572	0x72657375	0x5000302f	0x3d485441
	0x7fffffffefa0:	0x7273752f	0x636f6c2f	0x732f6c61	0x3a6e6962
	0x7fffffffefb0:	0x7273752f	0x636f6c2f	0x622f6c61	0x2f3a6e69
	0x7fffffffefc0:	0x2f727375	0x6e696273	0x73752f3a	0x69622f72
	0x7fffffffefd0:	0x732f3a6e	0x3a6e6962	0x6e69622f	0x6f722f00
	0x7fffffffefe0:	0x742f746f	0x2f747365	0x74736574	0x6e69625f
	0x7fffffffeff0:	0x65697261	0x00732f73	0x00000000	0x00000000
																	22
																	SSH_TTY=/dev/pts/3
																	COLUMNS=114
																	MAIL=/var/mail/root
																	SHELL=/bin/bash
																	TERM=xterm-256color
																	SHLVL=1
																	LOGNAME=root
																	XDG_RUNTIME_DIR=/run/user/0
																	PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
																	/root/test/test_binaries/s



Okay, so I wrote a basic script to check the hex data to verify that the strigns are on the stack. So yeah, they are. So now I need to push thosse strings onto the stack again(me talking to unicorn)!



	UNICORN DUMP!!!
			0x19ffe61	01000000[argc] 00000000 b8ff9f01[ENVP] 00000000

							#	0x19ffe49

			0x19ffe71	21000000[AT_SYSINFO_EHDR] 00000000 41414141 00000000
			0x19ffe81	10000000[AT_HWCAP] 00000000 42424242 00000000
			0x19ffe91	06000000[AT_PAGESZ] 00000000 00100000 00000000
			0x19ffea1	11000000[AT_CLKTCK] 00000000 64000000 00000000
			0x19ffeb1	03000000[AT_PHDR] 00000000 40004000 00000000
			0x19ffec1	04000000[AT_PHENT] 00000000 38000000 00000000
			0x19ffed1	05000000[AT_PHNUM] 00000000 06000000 00000000
			0x19ffee1	07000000[AT_BASE] 00000000 00000000 00000000
			0x19ffef1	08000000[AT_FLAGS] 00000000 00000000 00000000
			0x19fff01	09000000[AT_ENTRY] 00000000 90098000 00000000
			0x19fff11	0b000000[AT_UID] 00000000 00000000 00000000
			0x19fff21	0c000000[AT_EUID] 00000000 00000000 00000000
			0x19fff31	0d000000[AT_GID] 00000000 00000000 00000000
			0x19fff41	0e000000[AT_EGID] 00000000 00000000 00000000
			0x19fff51	17000000[AT_SECURE] 00000000 00000000 00000000
			0x19fff61	19000000[AT_RANDOM] 00000000 a1ff9f01 00000000
			0x19fff71	1f000000[AT_EXECFN] 00000000 d5ff9f01 00000000
			0x19fff81	0f000000[AT_PLATFORM] 00000000 b1ff9f01 00000000
			0x19fff91	00000000[AT_NULL] 00000000 00000000 00000000

				(	am I missing some aligning ? )

			0x19fffa1	8a36d43c 34eafdcd a7e0d644 b38e2b0a 			(this is random data!)


			0x19fffb1	7838365f 36340050([x86_64]) 57443d2f 726f6f74 
			0x19fffc1	2f746573 742f7465 73745f62 696e6172
			0x19fffd1	69657300 2f726f6f 742f7465 73742f74
			0x19fffe1	6573745f 62696e61 72696573 2f730000
			0x19ffff1	00000000 00000000 00000000 0000







0x19ffe49	01000000 00000000 00000000 00000000
0x19ffe59	21000000 00000000 41414141 00000000
0x19ffe69	10000000 00000000 42424242 00000000
0x19ffe79	06000000 00000000 00100000 00000000
0x19ffe89	11000000 00000000 64000000 00000000
0x19ffe99	03000000 00000000 40004000 00000000
0x19ffea9	04000000 00000000 38000000 00000000
0x19ffeb9	05000000 00000000 06000000 00000000
0x19ffec9	07000000 00000000 00000000 00000000
0x19ffed9	08000000[RSP 		ends here] 00000000 00000000 00000000
0x19ffee9	09000000[RSP 		walks here....] 00000000 90098000 00000000
0x19ffef9	0b000000 00000000 00000000 00000000
0x19fff09	0c000000 00000000 00000000 00000000
0x19fff19	0d000000 00000000 00000000 00000000
0x19fff29	0e000000 00000000 00000000 00000000
0x19fff39	17000000 00000000 00000000 00000000
0x19fff49	19000000 00000000 89ff9f01 00000000
0x19fff59	1f000000 00000000 e4ff9f01 00000000
0x19fff69	0f000000 00000000 99ff9f01 00000000
0x19fff79	00000000 00000000 00000000 00000000
0x19fff89	a70f59be fac517df 82e74914 43cf8ed5
0x19fff99	7838365f 36340000 00000000 00000000
0x19fffa9	00000000 00000000 00000000 00000000
0x19fffb9	00000000 00000000 00000000 00000000
0x19fffc9	00000000 00000000 00000000 00000000
0x19fffd9	00000000 00000000 0000002f 726f6f74
0x19fffe9	2f746573 742f7465 73745f62 696e6172
0x19ffff9	6965732f 7300













Okay so wer are now in _dl_discover_osversion, teh stack is nicely used to store some data. A lot of data actually. 


0x7fffffffeac8:	0x756e6547	0x00000000	0x00400aae	0x00000000
0x7fffffffead8:	0x00400bf4	0x00000000	0x00000000	0x00000000
0x7fffffffeae8:	0x00000000	0x00000001	0xffffec18	0x00007fff
0x7fffffffeaf8:	0x00400aae	0x00000000	0x00000000	0x00000000
0x7fffffffeb08:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffeb18:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffeb28:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffeb38:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffeb48:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffeb58:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffeb68:	0x00000000	0x00000000	0x756e6547	0x00000000
0x7fffffffeb78:	0x00400aae	0x00000000	0x00000001	0x00000000
0x7fffffffeb88:	0xffffec18	0x00007fff	0x00401690	0x00000000
0x7fffffffeb98:	0x004010c2	0x00000000	0xffffec08	0x00007fff
0x7fffffffeba8:	0x0040111f	0x00000000	0x00401720	0x00000000
0x7fffffffebb8:	0x00000000	0x00000000	0x00000006	0x0000003c
0x7fffffffebc8:	0x00000001	0x00000030	0x00000000	0x00000000
0x7fffffffebd8:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffebe8:	0x00000000	0x00000000	0x00000000	0x00000000
---Type <return> to continue, or q <return> to quit---
0x7fffffffebf8:	0x004009ba	0x00000000	0xffffec08	0x00007fff
0x7fffffffec08:	0x00000000	0x00000000	0x00000001	0x00000000
0x7fffffffec18:	0xffffee1c	0x00007fff	0x00000000	0x00000000
0x7fffffffec28:	0xffffee42	0x00007fff	0xffffee77	0x00007fff
0x7fffffffec38:	0xffffee86	0x00007fff	0xffffee98	0x00007fff
0x7fffffffec48:	0xffffeeab	0x00007fff	0xffffeeb5	0x00007fff


	after the syscall.....
	arguments are pushed to the stack
		-	note to self : check if the size is static.	It should be given the structure ?

		-	I checked
				   The length of the arrays in a struct utsname is unspecified (see
					NOTES); the fields are terminated by a null byte ('\0').

			However...

					 The length of the fields in the struct varies.  Some operating
		       systems or libraries use a hardcoded 9 or 33 or 65 or 257.  Other
		       systems use SYS_NMLN or _SYS_NMLN or UTSLEN or _UTSNAME_LENGTH.
		       Clearly, it is a bad idea to use any of these constants; just use
		       sizeof(...).  Often 257 is chosen in order to have room for an
		       internet hostname.

		   Looking at the stack with my eyes it looks like it has a hardcoded size.
		   it seems to be 64 bytes. (4 * 4) * 4

		   future me, past me you had a off by one ! its size is 65!

0x7fffffffe8f0:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffe900:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffe910:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffe920:	0x00000000	0x00000000	0x00000000	0x00000000

0x7fffffffe930:	0x756e694c	0x00000078	0x00000000	0x00000000			sys_anme
0x7fffffffe940:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffe950:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffe960:	0x00000000	0x00000000	0x00000000	0x00000000

0x7fffffffe970:	0x6c757600	0x672e7274	0x74736575	0x00000000			node_name
0x7fffffffe980:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffe990:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffe9a0:	0x00000000	0x00000000	0x00000000	0x00000000

0x7fffffffe9b0:	0x2e340000	0x2d302e39	0x6d612d38	0x00343664			release
0x7fffffffe9c0:	0x00000000	0x00000000	0x00000000	0x00000000				->	at 0x435d38
0x7fffffffe9d0:	0x00000000	0x00000000	0x00000000	0x00000000				->	should point here 		(this is actually the something....)
0x7fffffffe9e0:	0x00000000	0x00000000	0x00000000	0x00000000

0x7fffffffe9f0:	0x23000000	0x4d532031	0x65442050	0x6e616962			version
0x7fffffffea00:	0x392e3420	0x3031312e	0x642b332d	0x75396265
0x7fffffffea10:	0x32282036	0x2d383130	0x302d3031	0x00002938
0x7fffffffea20:	0x00000000	0x00000000	0x00000000	0x00000000

0x7fffffffea30:	0x00000000	0x5f363878	0x00003436	0x00000000			machine
0x7fffffffea40:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffea50:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffea60:	0x00000000	0x00000000	0x00000000	0x00000000

0x7fffffffea70:	0x00000000	0x6f6e2800	0x0029656e	0x00000000			domainname
0x7fffffffea80:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffea90:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffeaa0:	0x00000000	0x00000000	0x00000000	0x00000000

0x7fffffffeab0:	0x00000000	0x00000000	0x00401690	0x00000000			done

(where it was before the syscall)
0x7fffffffeac0:	0x00401720	0x00000000	0x756e6547	0x00000000
0x7fffffffead0:	0x00400aae	0x00000000	0x00400bf4	0x00000000
0x7fffffffeae0:	0x00000000	0x00000000	0x00000000	0x00000001
0x7fffffffeaf0:	0xffffec18	0x00007fff	0x00400aae	0x00000000
0x7fffffffeb00:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffeb10:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffeb20:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffeb30:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffeb40:	0x00000000	0x00000000	0x00000000	0x00000000
---Type <return> to continue, or q <return> to quit---
0x7fffffffeb50:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffeb60:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffeb70:	0x756e6547	0x00000000	0x00400aae	0x00000000
0x7fffffffeb80:	0x00000001	0x00000000	0xffffec18	0x00007fff
0x7fffffffeb90:	0x00401690	0x00000000	0x004010c2	0x00000000
0x7fffffffeba0:	0xffffec08	0x00007fff	0x0040111f	0x00000000
0x7fffffffebb0:	0x00401720	0x00000000	0x00000000	0x00000000
0x7fffffffebc0:	0x00000006	0x0000003c	0x00000001	0x00000030
0x7fffffffebd0:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffebe0:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffebf0:	0x00000000	0x00000000	0x004009ba	0x00000000
0x7fffffffec00:	0xffffec08	0x00007fff	0x00000000	0x00000000






Now I hit __libc_setup_tls, what is tls? It can't be related to tls certificates???
	-	no

	-	found this 	https://stackoverflow.com/questions/30377020/on-linux-is-tls-set-up-by-the-kernel-or-by-libc-or-other-language-runtime

		seems to be thread-local storage?


	-	https://stuff.mit.edu/afs/sipb/project/gcc-3.2/OldFiles/share/glibc-2.3.1//sysdeps/generic/libc-tls.c


	-	note to future self, __libc_setup_tls was looking at the start of the binary,
		I thougth it was part of the program header, but It wasn't will look more at it later. Hardcoded for now.


Congrats! You cheated your way to brk!
	-	new syscall manpage!
		http://man7.org/linux/man-pages/man2/brk.2.html


		(seems like I have miscalculated the BRK from segments, so using static fro now.)
		Looking at the brk syscall....
			(gdb) info registers
			rax            0xc	12
			rcx            0xc	12

			r11            0x206	518



				(gdb) info registers
				rax            0x6b6000	7036928
				rcx            0x400994	4196756

				r11            0x346	838



			rax            0xc	12
			rbx            0x6b6000	7036928
			rcx            0xc	12
			rdx            0x6b6000	7036928


				rax            0x6b71c0	7041472
				rbx            0x6b6000	7036928
				rcx            0x400994	4196756
				rdx            0x6b6000	7036928

		also brk seems to be sbrk? Only size adjustment...

Found this https://filippo.io/linux-syscall-table/ , nice table.
	-	I hit the arch_prctl, it is kinda weired. Should I assign the program a PID? Maybe, however the load and restore regsiter functions are usign ptrace? need to check it deeper. 


	-	Hardcoded it for now since it is only used once!


NEW SYScall  0x59!
	-	readlink
		-	not sure how I will fix this in the futrue.
			-	should the user be forced to provide full path?
			-	I can find it with the cwd tho, so it can eaisly be found if not provided full path.


Now I got to ptmalloc_init, it tries to read from 0xffffffffffffffd8 (-40), but that is unallocated... 
	-	is this because I did something bad at arch_prctl?

	-	nope !  mov        rax, 0xffffffffffffffd8

		-	am I supposed to handle this ? 
		-	like fs is zero
		-	fs should read from 0 to -40 ?
		-	strange...
		
 ptmalloc_init
 	-	0000000000414274         mov        rbx, qword [rbp] 
 	-	rbp should be pointing to 0xffffee42 ? (gdb)
 	-	that is a envp variable...
 	-	hm...
 		-	that points to 0x00000008

 		-	NO! You looked at 0x7fffffffed40....
 		-	0x7fffffffee40 points to the start of the envp....
 		-	the one regarding SSH!

 		-	maybe this is like the aux, looking for dicts?
 		-	it tries to find the end....

	 		-	yes!
	 		-	seems like it looks for AIL=/var

	 			-	actuall looking at all the cmp instructions, it seems to look 
	 				0x4d414c4c4f435f
	 				(MALLOC_)
	 			-	past me, look at the static data, not the gdb breakpoint data....

	 		-	okay so it check if we have defined some malloc ? 
	 			- I think you can apply some malloc rules as envp, so I guess this is where it checks for that ?
 getenv	
 	-	name->action should be obvious...


 	-	gdb and unicorn split at 0x406cc3
 		-	because unicorn has zero envp added (currently)
 		and gdb has many...
 	-	so I guess this is just to patch?
 	-	yes, given what I see this seems to be the case. However it seems to pop a lot from the stack.... I wounder why... It would be logical to just pop of one value? I think each envp string was zero terminated?


now at __memset_avx2_unaligned_erms
	-	did I actually find a unicorn bug this time?
		-	I need to patch the instruction....

	-	me reading unicorn/qemu
		-	disas_insn
			-	this function seems to do some calcs of size
				tb->size = pc_ptr - pc_start;

				-	well I compiled unicorn to dbeug that size, and well it said 38. GR!

				-	make clean && UNICORN_ARCHS="x86" ./make.sh && ./make.sh install
				
		-	why is there no nice way to have qemu as a library...			
			-	maybe why unicorn is so nice...


		-	okay so all the magic happens inside translate.c
			-	however....

		-	https://github.com/golang/go/issues/14068

		-	https://www-user.tu-chemnitz.de/~heha/viewchm.php/hs/x86.chm/x86.htm

		-	https://wiki.osdev.org/X86-64_Instruction_Encoding
		-	http://xxeo.com/single-byte-or-small-x86-opcodes




			-	instruction to hex
				['0xc5', '0xf9', '0x6e', '0xc6']

					vmovd xmm0, esi;



				Qemu reports
					/* 2-byte VEX */
				-	then breaks...

				then goes to 

					case 0xc5: /* lds Gv */
						/* In CODE64 this is VEX2; see above.  */
						op = R_DS;
						goto do_lxx;

				that then runs some opertaions on the data.
				    do_lxx:
				        ot = dflag != MO_16 ? MO_32 : MO_16;
				        modrm = cpu_ldub_code(env, s->pc++);
				        reg = ((modrm >> 3) & 7) | rex_r;
				        mod = (modrm >> 6) & 3;
				        if (mod == 3)
				            goto illegal_op;
				        gen_lea_modrm(env, s, modrm);
				        gen_op_ld_v(s, ot, *cpu_T[1], cpu_A0);
				        gen_add_A0_im(s, 1 << ot);
				        /* load the segment first to handle exceptions properly */
				        gen_op_ld_v(s, MO_16, *cpu_T[0], cpu_A0);
				        gen_movl_seg_T0(s, op, pc_start - s->cs_base);
				        /* then put the data */
				        gen_op_mov_reg_v(tcg_ctx, ot, reg, *cpu_T[1]);
				        if (s->is_jmp) {
				            gen_jmp_im(s, s->pc - s->cs_base);
				            gen_eob(s);
				        }
				        break;
				it will then break out..... what.
				is this to keep it cycle correct? or maybe I need more info about opcode handling in x86

			-	found this
				-	https://stackoverflow.com/questions/23788236/get-size-of-assembly-instructions/23843450#23843450

				-	also this	http://www.ref.x86asm.net/coder32.html
				
			-	ooo this is cool https://cmpsb.net/asm/x86/instr/view/211/MOVDQA

			also this one
				https://github.com/asmjit/asmdb
				it has some good info!

				{
				  "name": "vmovdqa",
				  "arch": "ANY",
				  "encoding": "RM",
				  "implicit": 0,
				  "commutative": 0,
				  "privilege": "L3",
				  "opcodeString": "VEX.128.66.0F.WIG 6F /r",
				  "opcodeValue": 111, // 0x6f 
				  "fields": {},
				  "operations": {},
				  "extensions": {
				    "AVX": true
				  },
				  "attributes": {},
				  "specialRegs": {},
				  "operands": [
				    {
				      "type": "reg",
				      "data": "xmm",
				      "optional": false,
				      "implicit": false,
				      "restrict": "",
				      "zext": true,
				      "read": false,
				      "write": true,
				      "commutative": false,
				      "reg": "xmm",
				      "regType": "xmm",
				      "mem": "",
				      "memSize": -1,
				      "memOff": false,
				      "memSeg": "",
				      "memFar": false,
				      "vsibReg": "",
				      "vsibSize": -1,
				      "bcstSize": -1,
				      "imm": 0,
				      "immSign": "",
				      "immValue": null,
				      "rel": 0,
				      "rwxIndex": -1,
				      "rwxWidth": -1
				    },
				    {
				      "type": "reg/mem",
				      "data": "xmm/m128",
				      "optional": false,
				      "implicit": false,
				      "restrict": "",
				      "zext": false,
				      "read": true,
				      "write": false,
				      "commutative": false,
				      "reg": "xmm",
				      "regType": "xmm",
				      "mem": "m128",
				      "memSize": 128,
				      "memOff": false,
				      "memSeg": "",
				      "memFar": false,
				      "vsibReg": "",
				      "vsibSize": -1,
				      "bcstSize": -1,
				      "imm": 0,
				      "immSign": "",
				      "immValue": null,
				      "rel": 0,
				      "rwxIndex": -1,
				      "rwxWidth": -1
				    }
				  ],
				  "prefix": "VEX",
				  "opcodeHex": "6F",
				  "l": "128",
				  "w": "WIG",
				  "pp": "66",
				  "mm": "0F",
				  "vvvv": "",
				  "_67h": false,
				  "rm": "r",
				  "rmInt": -1,
				  "ri": false,
				  "rel": 0,
				  "fpu": false,
				  "fpuTop": 0,
				  "vsibReg": "",
				  "vsibSize": -1,
				  "broadcast": false,
				  "bcstSize": -1,
				  "kmask": false,
				  "zmask": false,
				  "er": false,
				  "sae": false,
				  "tupleType": "",
				  "elementSize": -1
				}
		searching for 6f in qemu 
		        case 0x6f: /* movq mm, ea */
		            if (mod != 3) {
		                gen_lea_modrm(env, s, modrm);
		                gen_ldq_env_A0(s, offsetof(CPUX86State, fpregs[reg].mmx));
		            } else {
		                rm = (modrm & 7);
		                tcg_gen_ld_i64(tcg_ctx, cpu_tmp1_i64, cpu_env,
		                               offsetof(CPUX86State,fpregs[rm].mmx));
		                tcg_gen_st_i64(tcg_ctx, cpu_tmp1_i64, cpu_env,
		                               offsetof(CPUX86State,fpregs[reg].mmx));
		            }
		            break;

		but I patched qemu to debug the traces.... and I did not see it spit out 6f. BUT! Unicorn does report wrong size, so maybe it takes the wrong branch all together?

			- my mistake...	it actually gets executed!
				-	well, my mistake was acutally looking at wrong arguments of vmovdqa (diffrent opcodes given diffrent arguments!), I looked at 0x6f and 0x6e got excecuted :=)


			-	I think this name changes confuses me. 

			OKAY from https://www.felixcloutier.com/x86/movd:movq
				-	"VEX.128.66.0F.W0 6E / VMOVD xmm1, r32/m32	A	V/V	AVX	Move doubleword from r/m32 to xmm1."
				

		looking a again at translate.c code !
		-	['0xc5', '0xf9', '0x6e', '0xc6']
			-	 /* Collect prefixes.  */
				    switch (b) {
				    	/*
				    			a lot of checks
				    	*/
				  }
				 	-	it will break out at 
							case 0xc5: /* 2-byte VEX */
    						case 0xc4: /* 3-byte VEX */

    					-	this on correct based on https://www.felixcloutier.com/x86/movd:movq



    		-	['0xc5', '0xf9', '0x6e', '0xc6']
    			-	but then the next byte is 0xc6... is that correct?
    			-	yes, it


	    			-	https://wiki.osdev.org/X86-64_Instruction_Encoding#Legacy_Prefixes
	    				-	if you look carefully in the
	    					switch mentioned above you see
		    					case 0xc5: /* 2-byte VEX */
		    					case 0xc4: /* 3-byte VEX */
		    					-	this is where we break
		    			-	the reason it breaks and have moved the pc to 0xc6, is beacause it already stores the vex from within the switch!

		    		-	int vex3, vex2 = cpu_ldub_code(env, s->pc);
		    				-	rex_r = (~vex2 >> 4) & 8;
		    			-	you can see it read out rex_r and assign  vex3 = vex2;

		    	-	okay wait a second
		    		-	so 0xC5 signals that this a two byte vex...
		    			- from https://wiki.osdev.org/X86-64_Instruction_Encoding#Legacy_Prefixes
			    			A VEX instruction whose values for certain fields are VEX.~X == 1, VEX.~B == 1, VEX.W/E == 0 and map_select == b00001 may be encoded using the two byte VEX escape prefix. The layout is as follows:
			    			  7                           0       7                           0
							+---+---+---+---+---+---+---+---+   +---+---+---+---+---+---+---+---+
							| 1   1   0   0   0   1   0   1 |   |~R |     ~vvvv     | L |   pp  |
							+---+---+---+---+---+---+---+---+   +---+---+---+---+---+---+---+---+
						
						-	but that means 0x6e and 0xc6 is used for what?
							-	okay let's say 0x6e is the opcode... then what is 0xc6????
							-	proably something obvious i'm missing...	lets look at more code!

				-	okay then we get to 
						case 0xc6:
					    case 0xc7: /* mov Ev, Iv */
					    	it will then read the another byte modrm = cpu_ldub_code(env, s->pc++); !
					   
					   	-	okay then we only have one byte left to find...
					   		-	no.... wait!
					   			-	the pc is already at 0xc6, when you read another byte you should go out of bounds.... let me check!
					   				-	yes !	pc will be at 1000004
					   				-	and we are reading the value 0!
					   			-	okay so we leave that case statment at PC = 1000003, in other words, we have excecuted the last instruction....

					   		-	after         val = insn_get(env, s, ot);
					   		-	the pc will point 0x1000006 going more of bounds.....

					   	-	let me check the disas
					   			-	maybe pc is set at 0x1000006, because of some padding?
					   	-	okay vmovd      xmm0, esi
					   		-	next is 
					   			-	mov        rax, rdi
					   		-	boom... this is defiently a BUG!
					   	0000000000431860         vmovd      xmm0, esi;                                   0000000000431864         mov        rax, rdi;
					   	0000000000431867         vpbroadcastb xmm0, xmm0
					   		-	it would excepct some align padding, but since this a classic the size of the mov instruction is 0x3 so the pc can't jump to the vpbroadcastb!
					   			-	in other words... the instruction should not read that much !
					   				-	or maybe the actual problem is with the compiler????
					   	
					   	-	okay so I comment out the code form 	
							   	case 0xc6:
							    case 0xc7: /* mov Ev, Iv */
							-	makes it stop go out of bounds...
							-	also prints out the size from unicorn without extra noise!

						-	THANK YOU UNICRON FOR NICE COMMENT
							-	 // Unicorn: patch the callback for the instruction size
    				
    					-	okay the real magic is here
    						-	            *(save_opparam_ptr + 1) = s->pc - pc_start;

    					-	so lets check the delta ...


    						the delta is
    							first...
    							pc_now = 1000003
								pc_late = 1000000
									======
									======
								late...
    							pc_now = 1000004
								pc_start = 1000003
						-	trying to add another s->pc++;	will make it go out of bounds again....


						-	okay so in case 0xc7: /* mov Ev, Iv */
							-	you read the modrm, and actually points PC to the next instruction... That is correct!

						-	okay so I guess it calculates evreything correctly.... It runs the parsing correct, but the problem migth be at at way unicorn calculates ?
							like unicorn does it this way

							        if (changed_cc_op) {
							            if (cc_op_dirty)
							#if TCG_TARGET_REG_BITS == 32
							                *(save_opparam_ptr + 16) = s->pc - pc_start;
							            else
							                *(save_opparam_ptr + 14) = s->pc - pc_start;
							#else
							                *(save_opparam_ptr + 12) = s->pc - pc_start;
							            else
							                *(save_opparam_ptr + 10) = s->pc - pc_start;
							#endif
							        } else {
							            *(save_opparam_ptr + 1) = s->pc - pc_start; // where magic happens
							        }
							- I mean ... s->pc - pc_start actually makes sense...
								-	given that the emulations of the opcode should be correct, this should 

								-	helper_uc_tracecode ! 
									-	this reports the callback function!

								-	probably from gen_helper_uc_tracecode ? 
									-	qemu have a lot of #defines to make cross platform eaiser from a code style point of view, but it's a mess to search for ....
									-	nice gen_helper_uc_tracecode is nowhere in the code :=)
										-	only excecuted... GREAT!

									-	okay maybe this is actually some weired python thing, you know when I wrote a c python module I had to give them some weired names to make things work....
										if you look!
											-	   gen_helper_uc_tracecode(tcg_ctx, tsize, ttype, tuc, tpc);
											rmeove gen_
											- you have	helper_uc_tracecode
												- 	this is defiend
													-	defined as void helper_uc_tracecode(int32_t size, uc_hook_type type, void *handle, int64_t address)
												-	hm.... remove tcg_ctx and you have 
													gen_helper_uc_tracecode(tsize, ttype, tuc, tpc);
													mathces to 
													helper_uc_tracecode(int32_t size, uc_hook_type type, void *handle, int64_t address)
												-	okay so this make ssense!
											-	but even with casting the variable ( (int32_t)tsize ), it reports the wrong size ....
											-	okay but 0x1000000 to 0x1000003 
													-	0x1000000
													-	0x1000001
													-	0x1000002
													-	0x1000003
												-	you can count! IT'S FOUR! NOT 3 !!!! GR!
												-	okay... wait. 
													-	it should point to 0x1000004.....

							-	lets try to emulate a correct instruction!
								-	push 1 
								-	we get to
									    case 0x6a:
										        ot = mo_pushpop(s, dflag);
										        if (b == 0x68)
										            val = insn_get(env, s, ot);		->	here we read out the value! ( 1 ) -> will push pc to the next instruction
										        else
										            val = (int8_t)insn_get(env, s, MO_8);
										        tcg_gen_movi_tl(tcg_ctx, *cpu_T[0], val);
										        gen_push_v(s, *cpu_T[0]);
								-	okay so after running push 1, the pc will point to 1000002, the NEXT instruction!
									-	meaning that either I have totally misunderstood the operations of the vmovd instruciton or there is a bug :=)
									-	the delta is either way trying to check the diff between start_pc and next instruction, obviously.

							-	i'm starting to think that the main problem is that it should be usign the last argument for something
								but doesn't...

									-	let's see
									-	0xC5 		->	/* 2-byte VEX */
										-	then it reads the vex vectro at 0xf9
										-	
									-	then it check the opcode that points to 0x6e
										-	that lands at outsS....	 a string ops...
											-	obviously WRONG!
											
								-	okay let's try to add some input to the issue I opened.

So I have tried to debug the problem. The problem seems to be regarding parsing the vex opcode. After doing the switch check under "Collect prefixes", the switch statement for opcodes points to what I'm pretty sure is the wrong opcode. In _reswitch_ the switch(b), will have the value 0x6e, however 0x6e is a opcode for string ops. Which is interacting with I/O ports (seems wrong given that vmovd is moving qword between registers, not interacting with I/O ports). However if you look at 0xc6(last byte of the instruction), it points to _mov Ev, Iv_, I feel this is more correct. 

So "vmovd xmm0, esi;" encodes to ['0xc5', '0xf9', '0x6e', '0xc6']. 0xc5 means that this is a 2-byte VEX, you can see it read in the vex data at the line with the following code 
`int vex3, vex2 = cpu_ldub_code(env, s->pc);` (pc will here point at 0xf9). A few liens later ` s->pc++;` is executed. All of this seems okay. However then there is the` if (b == 0xc5)`,  it will read the opcode as `b = cpu_ldub_code(env, s->pc++);`. This is what I believe is wrong. Since the value it reads out is 0x6e and 0x6e is as I said a opcode for string ops. 

Patching the original switch statement under "Collect prefixes" to make the switch check for opcode in _reswitch_ point to 0xc6 makes the emulation exit normally. Without this patch the pc will go out of bounds. Since after the function _disas_insn_ is done, pc will point at 0xc6.
(I just added this line as a basic patch)
`b = cpu_ldub_code(env, s->pc);` after `b = cpu_ldub_code(env, s->pc++);` under the check ` if (b == 0xc5)`. I'm sure this will break some other instruction support. I haven't tested the patch with other instructions, only with the test script above. I have probably done something wrong, I doubt the solution is this simple. However, I hope this analysis give more insight to people more knowledgeable about this special instruction (and x86 instruction encoding) and make creating a good patch easier.


		-	lesson learned, don't always trust git fetch....
			-	from now on I will ALWAYS git clone from master to test before opening a issue....

			-	WRONG!	Always check for pip conflict....



		-	 _dl_non_dynamic_init
			-	will actually check fro envp malloc,	well this makes sense...
					kinda want to look for any other conflict...

			-	 mov        rdi, qword [_dl_sysinfo_dso]          
				-	does the stack look up!

				-	tired, migth check this tomorrow....

			
			-	actually seems to do check for the AT_SYSINFO_EHDR!
				-	and the starts of the location of AT_SYSINFO_EHDR starts with malloc.....
					so tired me wasn't totally off.

				-	never mind about malloc, it does not start with malloc...
					I had some data left in the stack string script, the vsdo starts with elf, it seems. Because it is a shared library! DUh.

				-	thank you gdb for letting me dump it so easily!

			-	there seems to be some mismatch in strlen and rindex, I think this just have to do 	with the pointer location. So In the delta script I just skip some checks in thoose sections.


			-	whooo!!! I did it !
		

		- 	fstat

			-	okay, so lets try to see the structure

				-	https://stackoverflow.com/questions/35392291/how-to-convert-between-a-dev-t-and-major-minor-device-numbers
					-	nice for compatability later....

				-	trying to find the definition of the fstat system call


				0x7fffffffe978:	0x00451e6a	0x00000000	
								0x00000011	0x00000000 		<- st_dev
				0x7fffffffe988:	0x00000005	0x00000000		<- st_ino
								0x00000001	0x00000000		<- st_mode
				0x7fffffffe998:	0x00002190	0x00000000		<- st_nlink
								0x00000005	0x00000000		<- st_uid
				0x7fffffffe9a8:	0x00008802	0x00000000		<- st_gid
								0x00000000	0x00000000		<- st_rdev
				0x7fffffffe9b8:	0x00000400	0x00000000		<- st_size
								0x00000000	0x00000000		<- st_blksize
				0x7fffffffe9c8:	0x5cee6c39	0x00000000		<-	st_blocks
								0x16030145	0x00000000	





				0x7fffffffe9d8:	0x5cee6c39	0x00000000	0x16030145	0x00000000
				0x7fffffffe9e8:	0x5cee670d	0x00000000	0x16030145	0x00000000
				0x7fffffffe9f8:	0x00000000	0x00000000	0x00000000	0x00000000
				0x7fffffffea08:	0x00000000	0x00000000	0x006b2300	0x00000000
				0x7fffffffea18:	0x004a6260	0x00000000	0x00489704	0x00000000
				0x7fffffffea28:	0x0040d004	0x00000000	0x006b2300	0x00000000
				0x7fffffffea38:	0xffffffff	0x00000000	0x00489704	0x00000000



- to future generations, reading kernel source code does help a lot to bootstrap unicorn!
	-	here are some resources that was nice.

			https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L603

			I have should  have read some kernel code before. Here is some of the things i'm
			missing 

			https://elixir.bootlin.com/linux/v3.18/source/fs/binfmt_elf.c#L149

	
			https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/elf.h

		'''
			special instruction 
				cpuid -> https://c9x.me/x86/html/file_module_x86_id_45.html
			xgetbv
				https://www.felixcloutier.com/x86/xgetbv

			# https://wiki.cdot.senecacollege.ca/wiki/X86_64_Register_and_Instruction_Quick_Start
				nice table


			https://filippo.io/linux-syscall-table/  <- BEST TABLE FOR SYSCALL LOOKUP
		'''


trying to fix xgetbv
	get illegal op....
		if (!(s->flags & HF_SVME_MASK) || !s->pe){

	-	hmmm, wrote a patch for instruction, need to do more research on this one.



Before fstat
0x7fffffffe978:	0x00451e6a	0x00000000	0xffffee09	0x00007fff
0x7fffffffe988:	0x00000000	0x00000000	0x0049d791	0x00000000
0x7fffffffe998:	0x00000015	0x00000000	0x00000140	0x00000000
0x7fffffffe9a8:	0x00000170	0x00000000	0x00000005	0x00000000
0x7fffffffe9b8:	0x00000015	0x00000035	0x00000000	0x00000000
0x7fffffffe9c8:	0x00000000	0x00000000	0x0000005b	0x0000006e
0x7fffffffe9d8:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffe9e8:	0x00000077	0x0000007c	0x00000020	0x00000000
0x7fffffffe9f8:	0x00000000	0x00000000	0x000000c2	0x00000000
0x7fffffffea08:	0x00000001	0x00000000	0x006b2300	0x00000000

After fstat
0x7fffffffe978:	0x00451e6a	0x00000000	0x00000011	0x00000000
0x7fffffffe988:	0x00000004	0x00000000	0x00000001	0x00000000
0x7fffffffe998:	0x00002190	0x00000000	0x00000005	0x00000000
0x7fffffffe9a8:	0x00008801	0x00000000	0x00000000	0x00000000
0x7fffffffe9b8:	0x00000400	0x00000000	0x00000000	0x00000000
0x7fffffffe9c8:	0x5d0787b0	0x00000000	0x18f7aca1	0x00000000
0x7fffffffe9d8:	0x5d0787b0	0x00000000	0x18f7aca1	0x00000000
0x7fffffffe9e8:	0x5d074dd2	0x00000000	0x18f7aca1	0x00000000
0x7fffffffe9f8:	0x00000000	0x00000000	0x00000000	0x00000000
0x7fffffffea08:	0x00000000	0x00000000	0x006b2300	0x00000000



